#### XPath (XML Path Language) - язык запросов, который использует древовидную структуру документа.
---
 1. XPath запрос всегда начинается с символа / или //  
Символ / аналогичен символу > в CSS-селекторе, а символ // — пробелу.
Их смысл:  
el1/el2 — выбирает элементы el2, являющиеся прямыми потомками el1;  
el1//el2 — выбирает элементы el2, являющиеся потомками el1 любой степени вложенности.  
Разница состоит в том, что в XPath, когда мы начинаем запрос с символа /,  мы должны указать элемент, являющийся корнем нашего документа.
Корнем всегда будет элемент с тегом <html>. Пример: /html/body/header  
Мы можем начинать запрос и с символа //. Это будет означать, что мы хотим найти всех потомков корневого элемента без указания корневого элемента.
В этом случае, для поиска того же хедера, мы можем выполнить запрос //header, так как других заголовков у нас нет.  
Важно! Такой поиск может быть неоднозначным. Например, запрос //div вернет вам все элементы с тегом \<div>.  
---
 2. Символ [ ] — это команда фильтрации  
Если по запросу найдено несколько элементов, то будет произведена фильтрация по правилу, указанному в скобках.
 
Правила фильтрации:  
* по любому атрибуту, будь то id, class, title (или любой другой). Например, мы хотим найти картинку с летящим котом, для этого можно выполнить запрос //img[@id='bullet']
* по порядковому номеру. Допустим, мы хотим выбрать вторую по порядку карточку с котом. Для этого найдем элемент с классом "row" и возьмем его второго потомка: //div[@class="row"]/div[2]
* по полному совпадению текста. Да, XPath — это единственный способ найти элемент по внутреннему тексту. Если мы хотим найти блок текста с котом-Лениным, можно воспользоваться XPath селектором //p[text()="Lenin cat"]. Такой селектор вернет элемент, только если текст полностью совпадет. Здесь важно сказать, что не всегда поиск по тексту — это хорошая практика, особенно в случае мультиязычных сайтов.
* по частичному совпадению текста или атрибута. Для этого нужна функция contains. Запрос //p[contains(text(), "cat")] вернет нам все абзацы текста, которые содержат слово cat. Точно так же можно искать по частичному совпадению других атрибутов, это удобно, если у элемента несколько классов. Посмотрите на код навбара сайта с котами. Его можно найти селектором //div[contains(@class, "navbar")]
в фильтрации еще можно использовать булевы операции (and, or, not) и некоторые простые арифметические выражения (но вообще не стоит, наверное). Допустим, мы хотим найти картинку обязательно с data-type "animal" и именем "bullet-cat", для этого подойдет запрос: //img[@name='bullet-cat' and @data-type='animal']
---
 3. Символ * — команда выбора всех элементов  
Например, можем найти текст в заголовке запросом //div/*[@class="jumbotron-heading"]. Это может быть удобно, когда мы не знаем точно тег элемента, который ищем.
---
 4. Поиск по классу в XPath регистрозависим (также, как и в случае поиска по CSS-селекторам).  
---
#### Полезные ссылки:  
[XPath Syntax](https://www.w3schools.com/xml/xpath_syntax.asp)  
[Примеры xpath-запросов к html](https://habr.com/post/114772/)  
[Не так страшен XPATH как его незнание](https://testerslittlehelper.wordpress.com/2016/07/10/real-xpath/)  
