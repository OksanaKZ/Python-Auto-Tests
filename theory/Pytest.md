<details>
<summary>Преимущества и недостатки</summary>
Плюсы:  

1) Полностью обратно совместим с фреймворками unittest и nosetest.  

2) Подробный отчёт с поддержкой цветовых схем из коробки.

3) Не требует написания дополнительных специфических конструкций в тестах, как того требует unittest (no boilerplate).

4) Для проверок используется стандартный assert из Python.

5) Возможность создания динамических фикстур (специальных функций, которые настраивают тестовые окружения и готовят тестовые данные).

6) Дополнительные возможности по настройке фикстур.

7) Параметризация тестов — для одного теста можно задать разные параметры (тест запустится несколько раз с разными тестовыми данными).

8) Наличие маркировок (marks), которые позволяют маркировать тесты для их выборочного запуска.

9) Возможность передавать дополнительные параметры через командную строку для настройки тестовых окружений.

10) Большое количество плагинов, которые расширяют возможности PyTest и позволяют решать узкоспециализированные проблемы, что может сэкономить много времени.

Минусы:

1) Требуется устанавливать дополнительно, так как он не входит в стандартный пакет библиотек Python, в отличие от unittest. Важно при настройке автоматического запуска тестов с помощью CI-сервера.

2) Требует более глубокого понимания языка Python, для применения фикстур, параметризации и других возможностей PyTest.
</details>

<details>
<summary>Правила запуска тестов</summary>
Когда мы выполняем команду pytest, тест-раннер собирает все тесты для запуска по определенным правилам:  
  
* если мы не передали никакого аргумента в команду, а написали просто pytest, тест-раннер начнёт поиск в текущей директории;
* как аргумент можно передать файл, путь к директории или любую комбинацию директорий и файлов, например: 
  
```
pytest scripts/selenium_scripts
# найти все тесты в директории scripts/selenium_scripts

pytest test_user_interface.py
# найти и выполнить все тесты в файле 

pytest scripts/drafts.py::test_register_new_user_parametrized
# найти тест с именем test_register_new_user_parametrized в указанном файле в указанной директории и выполнить
``` 
* дальше происходит рекурсивный поиск: то есть PyTest обойдет все вложенные директории;  
* во всех директориях PyTest ищет файлы, которые удовлетворяют правилу  test_*.py или *\_test.py (то есть начинаются на test_ или заканчиваются _test и имеют расширение .py);  
* внутри всех этих файлов находит тестовые функции по следующему правилу:

все тесты, название которых начинается с test, которые находятся вне классов;  

все тесты, название которых начинается с test внутри классов, имя которых начинается с Test (и без метода __init__ внутри класса).  
</details>

---

Если запустить PyTest с параметром -v (verbose, то есть подробный), то в отчёт добавится дополнительная информация со списком тестов и статусом их прохождения.  

В PyTest используется стандартный assert метод из языка Python, что делает код более очевидным. С помощью assert можно проверять любую конструкцию, которая возвращает True/False. Это может быть проверка равенства, неравенства, содержания подстроки в строке или любая другая вспомогательная функция, которую можно описать самостоятельно.  

Если нужно проверить, что тест вызывает ожидаемое исключение (довольно редкая ситуация для UI-тестов), можно использовать специальную конструкцию with pytest.raises(). Например, можно проверить, что на странице сайта не должен отображаться какой-то элемент:  
```
import pytest

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.common.exceptions import NoSuchElementException


def test_exception1():
    try:
        browser = webdriver.Chrome()
        browser.get("http://selenium1py.pythonanywhere.com/")
        with pytest.raises(NoSuchElementException):
            browser.find_element(By.CSS_SELECTOR, "button.btn")
            pytest.fail("Не должно быть кнопки Отправить")
    finally: 
        browser.quit()

def test_exception2():
    try:
        browser = webdriver.Chrome()
        browser.get("http://selenium1py.pythonanywhere.com/")
        with pytest.raises(NoSuchElementException):
            browser.find_element(By.CSS_SELECTOR, "no_such_button.btn")
            pytest.fail("Не должно быть кнопки Отправить")
    finally: 
        browser.quit()
```

В первом тесте элемент будет найден, поэтому ошибка NoSuchElementException, которую ожидает контекстный менеджер pytest.raises, не возникнет, и тест упадёт.  

```
test_3_3_9_pytest_raises.py:8 (test_exception1)
E   Failed: Не должно быть кнопки Отправить
```

Во втором тесте, как мы и ожидали, кнопка не будет найдена, и тест пройдет. 

