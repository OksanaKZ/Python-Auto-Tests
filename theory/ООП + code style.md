<details>
<summary>Code Style</summary>

### Отступы:  
```
# тест вне класса: отступа нет
def test_student_can_see_lesson_name_in_lesson_in_course_after_joining(self, driver):
    # все строки внутри теста с отступом
    page = CoursePromoPage(url=self.course.url, driver=driver)
    page.open()


class TestLessonNameInCourseForTeacher():
    @pytest.mark.regression
    # тест внутри класса, нужен дополнительный отступ
    def test_teacher_can_see_lesson_name_in_lesson_in_course(self, driver):
        # еще один отступ для каждой строки, и так с любым уровнем вложенности
        page = LessonPlayerPage(url=self.lesson_url, driver=driver)
        page.open()
        try:
            # плюс один отступ на каждый уровень вложенности
            dangerous_function()
        except:
            close_something()
```

Функции пишутся через_нижнее_подчеркивание:
```
def test_guest_can_see_lesson_name_in_lesson_without_course(self, driver):
```
Классы пишут с помощью CamelCase:
```
class TestLessonNameWithoutCourseForGuest():
```
Константы пишут в стиле UPPERCASE:
```
MAIN_PAGE = "/catalog"
```
</details>

<details>
<summary>ООП</summary>

### Базовые принципы ООП  
* Абстракция — отделение концепции от ее экземпляра;
* Полиморфизм — реализация задач одной и той же идеи разными способами;
* Наследование — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследственное отношение классов четко определяет их иерархию;
* Инкапсуляция — размещение одного объекта или класса внутри другого для разграничения доступа к ним.

### Главное:  
* Инкапсулируйте все, что может изменяться;
* Уделяйте больше внимания интерфейсам, а не их реализациям;
* Каждый класс в вашем приложении должен иметь только одно назначение;
* Классы — это их поведение и функциональность.

### Используйте следующее вместе с наследованием
* Делегация — перепоручение задачи от внешнего объекта внутреннему;
* Композиция — включение объектом-контейнером объекта-содержимого и управление его поведением; последний не может существовать вне первого;
* Агрегация — включение объектом-контейнером ссылки на объект-содержимое; при уничтожении первого последний продолжает существование.
</details>

<details>
<summary>Принципы для разработки</summary>
    
1. YAGNI  
You Aren’t Gonna Need It / Вам это не понадобится  
Если пишете код, то будьте уверены, что он вам понадобится. Не пишите код, если думаете, что он пригодится позже. Этот принцип применим при рефакторинге. Если вы занимаетесь рефакторингом метода, класса или файла, не бойтесь удалять лишние методы. Даже если раньше они были полезны – теперь они не нужны. Может наступить день, когда они снова понадобятся – тогда вы сможете воспользоваться git-репозиторием, чтобы воскресить их из мертвых.  
    
2. DRY  
Don’t Repeat Yourself / Не повторяйтесь  
Эта концепция была впервые сформулирована в книге Энди Ханта и Дэйва Томаса «Программист-прагматик: путь от подмастерья к мастеру». Идея вращается вокруг единого источника правды (single source of truth — SSOT).
В проектировании и теории информационных систем единый источник истины (SSOT) – это практика структурирования информационных моделей и схемы данных, которая подразумевает, что все фрагменты данных обрабатываются (или редактируются) только в одном месте. SSOT предоставляют достоверные, актуальные и пригодные к использованию данные. Использование SSOT позволит создать более прочную и понятную кодовую базу. Дублирование кода – пустая трата времени и ресурсов. Вам придется поддерживать одну и ту же логику и тестировать код сразу в двух местах, причем если вы измените код в одном месте, его нужно будет изменить и в другом. В большинстве случаев дублирование кода происходит из-за незнания системы. Прежде чем что-либо писать, проявите прагматизм: осмотритесь. Возможно, эта функция где-то реализована. Возможно, эта бизнес-логика существует в другом месте.

4. KISS  
Keep It Simple, Stupid / Будь проще  
Этот принцип был разработан ВМС США в 1960 году. Этот принцип гласит, что простые системы будут работать лучше и надежнее. Применительно к разработке ПО он значит следующее – не придумывайте к задаче более сложного решения, чем ей требуется. Одна из самых распространенных ошибок нашего времени – использование новых инструментов исключительно из-за того, что они блестят. Разработчиков следует мотивировать использовать новейшие технологии не потому, что они новые, а потому что они подходят для работы.  

4. Big Design Up Front  
Глобальное проектирование прежде всего  
Этот подход к разработке программного обеспечения очень важен, и его часто игнорируют. Прежде чем переходить к реализации, убедитесь, что все хорошо продумано. Зачастую продумывание решений избавляло нас от проблем при разработке… Внесение изменений в спецификации занимало час или два. Если бы мы вносили эти изменения в код, на это уходили бы недели. Многие разработчики считают, что если они не пишут код, то они не добиваются прогресса. Это неверный подход. Составив план, вы избавите себя от необходимости раз за разом начинать с нуля.  

5. SOLID  
Это наиболее известный принцип разработки ПО. Solid — это аббревиатура от:  

S) Single-responsibility principle /Принцип единственной ответственности  
Его важность невозможно переоценить. Каждый объект, класс и метод должны отвечать только за что-то одно. Если ваш объект/класс/метод делает слишком много, вы получите спагетти-код. Вот пример:
```
const saveTodo = async () => {
    try {
        response = await saveTodoApi(); 
        showSuccessPop('Success'); 
        window.location.href = '/successPage';
    } catch (error) { 
        showErrorPopup(`Error: ${error} `);
    }
}
```
Этот метод кажется безобидным, но на самом деле он делает слишком много:  
Сохраняет объект  
Обрабатывает уведомление в UI  
Выполняет навигацию  

Еще один побочный эффект такого кода – проблемы с тестированием. Запутанный функционал тестировать сложно.  

O) Open–closed principle / Принцип открытости-закрытости  
Программные объекты должны быть открыты для расширения, но закрыты для модификации. Речь о том, что нельзя переопределять методы или классы, просто добавляя дополнительные функции по мере необходимости. Хороший способ решения этой проблемы – использование наследования. В JavaScript эта проблема решается с помощью композиции. Простое правило: если вы изменяете сущность, чтобы сделать ее расширяемой, вы впервые нарушили этот принцип.  

L) Liskov substitution principle / Принцип подстановки Лисков  
Этот принцип гласит, что объекты старших классов должны быть заменимы объектами подклассов, и приложение при такой замене должно работать так, как ожидается.  

I) Interface segregation principle / Принцип разделения интерфейсов  
Этот принцип был сформулирован Робертом Мартином, когда он консультировал Xerox, и он очевиден. Объекты не должны зависеть от интерфейсов, которые они не используют. ПО должно разделяться на независимые части. Побочные эффекты необходимо сводить к минимуму, чтобы обеспечивать независимость.  
Убедитесь, что вы не заставляете объекты реализовывать методы, которые им никогда не понадобятся. Вот пример:
```
interface Animal {
  eat: () => void;
  walk: () => void;
  fly: () => void;
  swim: () => void;
}
```
Не все животные могут fly, walk или swim, поэтому эти методы не должны быть частью интерфейса или должны быть необязательными.  

D) Dependency inversion principle / Принцип инверсии зависимостей  
Этот принцип невозможно переоценить. Мы должны полагаться на абстракции, а не на конкретные реализации. Компоненты ПО должны иметь низкую связность и высокую согласованность. Заботиться нужно не о том, как что-то устроено, а о том, как оно работает. Простой пример – использование дат в JavaScript. Вы можете написать для них свой слой абстракции. Тогда если у вас сменится источник получения дат, вам нужно будет внести изменения в одном месте, а не в тысяче. Иногда добавление этого уровня абстракции требует усилий, но в конечном итоге они окупаются.  

6. Avoid Premature Optimization  
Избегайте преждевременной оптимизации  
Эта практика побуждает разработчиков оптимизировать код до того, как необходимость этой оптимизации будет доказана. Думаю, что если вы следуете KISS или YAGNI, вы не попадетесь на этот крючок. Прежде чем вы погрузитесь в детали реализации, убедитесь, что эти оптимизации действительно полезны. Очень простой пример – масштабирование. Вы не станете покупать 40 серверов из предположения, что ваше новое приложение станет очень популярным. Вы будете добавлять серверы по мере необходимости.  

7. Бритва Оккама  
Бри́тва О́ккама (иногда ле́звие О́ккама) — методологический принцип, в кратком виде гласящий: «Не следует множить сущее без необходимости» (либо «Не следует привлекать новые сущности без крайней на то необходимости»). Не создавайте ненужных сущностей без необходимости. Будьте прагматичны — подумайте, нужны ли они, поскольку они могут в конечном итоге усложнить вашу кодовую базу.
</details>
